# OffWeGo CI/CD Pipeline
# This workflow handles continuous integration and deployment for both Frontend and Backend

name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  NODE_VERSION: '20'
  DOCKER_REGISTRY: docker.io
  IMAGE_NAME: navyacs/offwego

jobs:
  # ============================================
  # Backend CI Jobs
  # ============================================
  backend-lint:
    name: Backend Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: Backend/package-lock.json

      - name: Install dependencies
        working-directory: ./Backend
        run: npm ci

      - name: Run ESLint
        working-directory: ./Backend
        run: npm run lint

  backend-build:
    name: Backend Build
    runs-on: ubuntu-latest
    needs: backend-lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: Backend/package-lock.json

      - name: Install dependencies
        working-directory: ./Backend
        run: npm ci

      - name: Build TypeScript
        working-directory: ./Backend
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist
          path: Backend/dist
          retention-days: 7

  # ============================================
  # Frontend CI Jobs
  # ============================================
  frontend-lint:
    name: Frontend Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./Frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./Frontend
        run: npm run lint

  frontend-build:
    name: Frontend Build
    runs-on: ubuntu-latest
    needs: frontend-lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./Frontend
        run: npm ci

      - name: Build Frontend
        working-directory: ./Frontend
        env:
          VITE_BASE_URL: ${{ secrets.VITE_BASE_URL || '/' }}
          VITE_SOCKET_URL: ${{ secrets.VITE_SOCKET_URL || '/' }}
          VITE_CLOUDINARY_CLOUD_NAME: ${{ secrets.VITE_CLOUDINARY_CLOUD_NAME }}
          VITE_CLOUDINARY_UPLOAD_PRESET: ${{ secrets.VITE_CLOUDINARY_UPLOAD_PRESET }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
          VITE_OPENCAGE_API_KEY: ${{ secrets.VITE_OPENCAGE_API_KEY }}
          VITE_IMAGE_URL: ${{ secrets.VITE_IMAGE_URL || '/' }}
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: Frontend/dist
          retention-days: 7

  # ============================================
  # Docker Build Job - Unified Image
  # ============================================
  docker-build-unified:
    name: Build Unified Docker Image
    runs-on: ubuntu-latest
    needs: [backend-build, frontend-build]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push unified image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VITE_BASE_URL=${{ secrets.VITE_BASE_URL || (format('https://{0}/', secrets.PRODUCTION_DOMAIN) != 'https:///' && format('https://{0}/', secrets.PRODUCTION_DOMAIN) || '/') }}
            VITE_SOCKET_URL=${{ secrets.VITE_SOCKET_URL || (format('https://{0}/', secrets.PRODUCTION_DOMAIN) != 'https:///' && format('https://{0}/', secrets.PRODUCTION_DOMAIN) || '/') }}
            VITE_CLOUDINARY_CLOUD_NAME=${{ secrets.VITE_CLOUDINARY_CLOUD_NAME }}
            VITE_CLOUDINARY_UPLOAD_PRESET=${{ secrets.VITE_CLOUDINARY_UPLOAD_PRESET }}
            VITE_STRIPE_PUBLISHABLE_KEY=${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
            VITE_OPENCAGE_API_KEY=${{ secrets.VITE_OPENCAGE_API_KEY }}
            VITE_IMAGE_URL=${{ secrets.VITE_IMAGE_URL || '/' }}
            VITE_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================
  # Deploy Job (Optional - Configure as needed)
  # ============================================
  deploy:
    name: Deploy to AWS EC2
    runs-on: ubuntu-latest
    needs: docker-build-unified
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to AWS EC2
        uses: appleboy/ssh-action@v1.0.0
        env:
          MONGO_URI: ${{ secrets.MONGO_URI }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          JWT_ACCESSTOKENSECRETKEY: ${{ secrets.JWT_ACCESSTOKENSECRETKEY }}
          JWT_REFRESHTOKEN: ${{ secrets.JWT_REFRESHTOKEN }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}
          DOMAIN_URL: ${{ secrets.DOMAIN_URL }}
          FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          NODEMAILER_EMAIL: ${{ secrets.NODEMAILER_EMAIL }}
          NODEMAILER_PASSWORD: ${{ secrets.NODEMAILER_PASSWORD }}
          PROD_DOMAIN: ${{ secrets.PRODUCTION_DOMAIN }}
        with:
          host: ${{ secrets.AWS_EC2_HOST }}
          username: ${{ secrets.AWS_EC2_USER }}
          key: ${{ secrets.AWS_EC2_SSH_KEY }}
          port: 22
          envs: >-
            MONGO_URI,REDIS_PASSWORD,JWT_ACCESSTOKENSECRETKEY,JWT_REFRESHTOKEN,STRIPE_SECRET_KEY,
            CLOUDINARY_CLOUD_NAME,CLOUDINARY_API_KEY,CLOUDINARY_API_SECRET,
            DOMAIN_URL,FIREBASE_SERVICE_ACCOUNT,GOOGLE_CLIENT_ID,NODEMAILER_EMAIL,NODEMAILER_PASSWORD,PROD_DOMAIN
          script: |
            mkdir -p ~/offwego/nginx
            cd ~/offwego
            
            # Construct .env file from individual environment variables
            cat <<EOF > .env
            PORT=1212
            NODE_ENV=production
            FRONTEND_URL="https://offwego.online"
            MONGO_URI="$MONGO_URI"
            REDIS_HOST=redis
            REDIS_PORT=6379
            REDIS_PASSWORD="$REDIS_PASSWORD"
            JWT_ACCESSTOKENSECRETKEY="$JWT_ACCESSTOKENSECRETKEY"
            JWT_REFRESHTOKEN="$JWT_REFRESHTOKEN"
            STRIPE_SECRET_KEY="$STRIPE_SECRET_KEY"
            CLOUDINARY_CLOUD_NAME="$CLOUDINARY_CLOUD_NAME"
            CLOUDINARY_API_KEY="$CLOUDINARY_API_KEY"
            CLOUDINARY_API_SECRET="$CLOUDINARY_API_SECRET"
            DOMAIN_URL="$DOMAIN_URL"
            FIREBASE_SERVICE_ACCOUNT='$FIREBASE_SERVICE_ACCOUNT'
            GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID"
            NODEMAILER_EMAIL="$NODEMAILER_EMAIL"
            NODEMAILER_PASSWORD="$NODEMAILER_PASSWORD"
            EOF
            
            echo "‚úÖ .env file generated from GitHub Secrets."
            
            # Use the PROD_DOMAIN secret if provided, otherwise fallback
            DOMAIN="${PROD_DOMAIN:-localhost}"
            echo "Deployment Domain: $DOMAIN"
            
            # Write the Nginx config using a LITERAL heredoc (cat <<'EOF') to prevent mangling
            cat <<'NGINX_EOF' > nginx/nginx.conf
            events {
                worker_connections 1024;
            }

            http {
                include       /etc/nginx/mime.types;
                default_type  application/octet-stream;
                gzip on;
                gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

                server {
                    listen 80;
                    server_name REPLACE_WITH_DOMAIN;
                    location /.well-known/acme-challenge/ { root /var/www/certbot; }
                    location / { return 301 https://$host$request_uri; }
                }

                server {
                    listen 443 ssl;
                    server_name REPLACE_WITH_DOMAIN;
                    ssl_certificate /etc/letsencrypt/live/REPLACE_WITH_DOMAIN/fullchain.pem;
                    ssl_certificate_key /etc/letsencrypt/live/REPLACE_WITH_DOMAIN/privkey.pem;
                    ssl_protocols TLSv1.2 TLSv1.3;
                    ssl_ciphers HIGH:!aNULL:!MD5;
                    ssl_prefer_server_ciphers on;

                    location / {
                        proxy_pass http://offwego-prod:1212;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                    }

                    location /socket.io/ {
                        proxy_pass http://offwego-prod:1212/socket.io/;
                        proxy_http_version 1.1;
                        proxy_set_header Upgrade $http_upgrade;
                        proxy_set_header Connection "upgrade";
                        proxy_set_header Host $host;
                        proxy_cache_bypass $http_upgrade;
                    }
                }
            }
            NGINX_EOF
            
            # Replace placeholder with actual domain
            sed -i "s/REPLACE_WITH_DOMAIN/$DOMAIN/g" nginx/nginx.conf

            # Write the docker-compose file directly
            cat <<'COMPOSE_EOF' > docker-compose.prod.yml
            services:
              redis:
                image: redis:alpine
                container_name: offwego-redis-prod
                restart: always
                command: redis-server --requirepass ${REDIS_PASSWORD}
                ports:
                  - "6379:6379"
            
              OffWeGo:
                image: navyacs/offwego:latest
                container_name: offwego-prod
                env_file: .env
                restart: always
                expose:
                  - "1212"
                environment:
                  NODE_ENV: production
                  PORT: 1212
                  MONGO_URI: ${MONGO_URI}
                  REDIS_HOST: redis
                  REDIS_PORT: 6379
                  REDIS_PASSWORD: ${REDIS_PASSWORD}
                  JWT_ACCESSTOKENSECRETKEY: ${JWT_ACCESSTOKENSECRETKEY}
                  STRIPE_SECRET_KEY: ${STRIPE_SECRET_KEY}
                  CLOUDINARY_CLOUD_NAME: ${CLOUDINARY_CLOUD_NAME}
                  CLOUDINARY_API_KEY: ${CLOUDINARY_API_KEY}
                  CLOUDINARY_API_SECRET: ${CLOUDINARY_API_SECRET}
                  DOMAIN_URL: ${DOMAIN_URL}
                  FIREBASE_SERVICE_ACCOUNT: ${FIREBASE_SERVICE_ACCOUNT}
                  GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
                depends_on:
                  - redis
              
              nginx:
                image: nginx:alpine
                container_name: offwego-nginx
                restart: always
                ports:
                  - "80:80"
                  - "443:443"
                volumes:
                  - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
                  - ./certbot/conf:/etc/letsencrypt:ro
                  - ./certbot/www:/var/www/certbot:ro
                depends_on:
                  - OffWeGo

              certbot:
                image: certbot/certbot
                container_name: offwego-certbot
                volumes:
                  - ./certbot/conf:/etc/letsencrypt
                  - ./certbot/www:/var/www/certbot
                entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
            COMPOSE_EOF
            
            # Log in to Docker Hub (using sudo for permissions)
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | sudo docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
            
            # Pull latest images
            sudo docker compose -f docker-compose.prod.yml pull
            
            # Restart services
            sudo docker compose -f docker-compose.prod.yml up -d
            
            # Initial SSL generation if certificate doesn't exist
            if [ "$DOMAIN" != "localhost" ] && [ ! -d "certbot/conf/live/$DOMAIN" ]; then
                echo "üöÄ Certificates not found for $DOMAIN. Requesting initial SSL certificates..."
                
                # Stop nginx if it's running to free up port 80 for standalone mode
                sudo docker compose -f docker-compose.prod.yml stop nginx
                
                sudo docker compose -f docker-compose.prod.yml run --rm -p 80:80 --entrypoint certbot certbot certonly --standalone --non-interactive --preferred-challenges http --email navyaaaa303@gmail.com --agree-tos --no-eff-email -d $DOMAIN
                
                echo "‚ôªÔ∏è Restarting services with new certificates..."
                sudo docker compose -f docker-compose.prod.yml up -d nginx
            fi

            # Check logs to ensure everything started correctly
            echo "üìã Checking backend logs for errors..."
            sleep 10
            sudo docker logs offwego-prod --tail 50

      # Option 2: Deploy to AWS ECS
      # Note: Requires a task-definition.json file in the root
      # - name: Deploy to AWS ECS
      #   uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      #   with:
      #     task-definition: task-definition.json
      #     service: offwego-service
      #     cluster: offwego-cluster

      # Option 3: Deploy to DigitalOcean App Platform (Disabled)
      # - name: Deploy to DigitalOcean
      #   uses: digitalocean/app_action@v1.1.6
      #   with:
      #     app_name: offwego
      #     token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      # Option 4: Deploy to Railway (Disabled)
      # - name: Deploy to Railway
      #   uses: bervProject/railway-deploy@main
      #   with:
      #     railway_token: ${{ secrets.RAILWAY_TOKEN }}
      #     service: offwego

      - name: Deployment complete
        run: echo "‚úÖ Deployment pipeline completed successfully!"

  # ============================================
  # Cleanup Job
  # ============================================
  cleanup:
    name: Cleanup Old Artifacts
    runs-on: ubuntu-latest
    needs: [backend-build, frontend-build]
    if: always()
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 30
          keep_minimum_runs: 10
